---

title: rfml_localization

keywords: fastai
sidebar: home_sidebar

summary: "Core functions for RF localization which includes kernelizing data.  Requires Sci-Kit Learn and Glmnet for Python"
description: "Core functions for RF localization which includes kernelizing data.  Requires Sci-Kit Learn and Glmnet for Python"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: 00_core.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="HFF_k_matrix" class="doc_header"><code>HFF_k_matrix</code><a href="https://github.com/elaird6/rfml_localization/tree/master/rfml_localization/core.py#L16" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>HFF_k_matrix</code>(<strong><code>fml</code></strong>=<em><code>None</code></em>, <strong><code>fm</code></strong>, <strong><code>kernel</code></strong>=<em><code>'laplacian'</code></em>, <strong><code>num_meas_array</code></strong>, <strong><code>varMs</code></strong>)</p>
</blockquote>
<p>Function to generate a kernelized matrix.  The kernel used
defaults to laplacian (manhattan distance).</p>
<p><strong><em>Parameters</em></strong></p>
<blockquote><p><strong>fml</strong> : ndarray of shape (n_examples, n_features)</p>
<ul>
<li>dictionary of reference measurements/observations with format of
<pre><code> [num_runs * n_types of measurements]x[measurements/features]</code></pre>
</li>
</ul>
<p><strong>fm</strong> : ndarray of shape (n_examples, n_features), optional</p>
<ul>
<li>set of measurements/observations of same format as fml</li>
</ul>
<p><strong>kernel</strong> : str, default = 'laplacian'</p>
<ul>
<li>This determines kernel - see scikit-learn's pairwise kernels
 function. Values typically used here are 'rbf' and 'laplacian'
 with other values including [‘additive_chi2’, ‘chi2’, ‘linear’,
 ‘poly’, ‘polynomial’, ‘sigmoid’, ‘cosine’]</li>
</ul>
<p><strong>num_meas_array</strong> : ndarray of shape  (n_types of measurements,), default = np.array([])</p>
<ul>
<li>numpy array that provides the number of each type of measurements
 (112ea TDOA, 16ea RSS, 8ea AoA is np.array([112,16,8])).  Note
 that if single total number or empty array of measurements
 then defaults to simply pairwise_kernel for entire dictionary.</li>
</ul>
<p><strong>varMs</strong> : ndarray of shape (n_types of measurements,), default = np.array([])</p>
<ul>
<li>scale factor for kernel/similarity measurement of each
 measurement type. It can be related to variance of each
 measurement type.</li>
</ul>
</blockquote>
<p><strong>Returns</strong></p>
<blockquote><p>returns a kernel matrix (k_matrix)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<hr>
<p><strong>HFF_k_matrix Examples</strong></p>
<p>Using <a href="/rfml_localization/RFsimulation"><code>RFsimulation</code></a>, generate a set of locations and associated TDoA measurements.  The measurements will be kernelized using <a href="/rfml_localization/core#HFF_k_matrix"><code>HFF_k_matrix</code></a>.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">rfml_localization.RFsimulation</span> <span class="k">as</span> <span class="nn">rfsim</span>
<span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="c1">#generate channel scenario using default channel parameters</span>
<span class="n">RFchannel_scenario1</span> <span class="o">=</span> <span class="n">rfsim</span><span class="o">.</span><span class="n">RFchannel</span><span class="p">()</span>

<span class="c1">#from channel scenario, generate locations for Tx and Rx and set of location observations</span>
<span class="n">RFchannel_scenario1</span><span class="o">.</span><span class="n">generate_RxTxlocations</span><span class="p">(</span><span class="n">n_rx</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">n_runs</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">rxtx_flag</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

<span class="c1">#create a set of TDoA measurements then kernelize (set seed to set random)</span>
<span class="n">RFchannel_scenario1</span><span class="o">.</span><span class="n">calculate_Rxxdelay</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">tdoa_kern</span> <span class="o">=</span> <span class="n">HFF_k_matrix</span><span class="p">(</span><span class="n">fml</span><span class="o">=</span><span class="n">RFchannel_scenario1</span><span class="o">.</span><span class="n">rxx_delay</span><span class="p">)</span>

<span class="c1">#create same set of of TDoA measurements using different method (same seed)</span>
<span class="n">RFchannel_scenario1</span><span class="o">.</span><span class="n">generate_Xmodel</span><span class="p">(</span><span class="n">meas_flag</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">tdoa_kernX</span> <span class="o">=</span> <span class="n">HFF_k_matrix</span><span class="p">(</span><span class="n">RFchannel_scenario1</span><span class="o">.</span><span class="n">X_model</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shape of original measurements:&quot;</span><span class="p">,</span> <span class="n">RFchannel_scenario1</span><span class="o">.</span><span class="n">rxx_delay</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shape of kernelized measurements:&quot;</span><span class="p">,</span> <span class="n">tdoa_kern</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shape of kernelized measurement X:&quot;</span><span class="p">,</span> <span class="n">tdoa_kern</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;First initial values using TDoA function:   </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">tdoa_kern</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">8</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;First initial values using X_model function:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">tdoa_kernX</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">8</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Shape of original measurements: (10000, 15)
Shape of kernelized measurements: (10000, 10000)
Shape of kernelized measurement X: (10000, 10000)
 
First initial values using TDoA function:   
 [1.00e+00 2.23e-16 1.07e-04 2.81e-16 3.16e-12 3.15e-05 9.56e-12 4.70e-04]
First initial values using X_model function:
 [1.00e+00 2.23e-16 1.07e-04 2.81e-16 3.16e-12 3.15e-05 9.56e-12 4.70e-04]
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="mse_EucDistance" class="doc_header"><code>mse_EucDistance</code><a href="https://github.com/elaird6/rfml_localization/tree/master/rfml_localization/core.py#L88" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>mse_EucDistance</code>(<strong><code>yV</code></strong>, <strong><code>yVhat</code></strong>)</p>
</blockquote>
<p>Scoring function to calculate the mean physical distance error of
estimated location versus the actual location.  This is the mean
Euclidean distance error</p>
<p><strong>Parameters</strong></p>
<blockquote><p><strong>y</strong> : ndarray of shape (n_obs, n_dims)</p>
<ul>
<li>Each row is a actual location with colums being cartesian coordinates
2D or 3D.</li>
</ul>
<p><strong>yhat</strong> : ndarray of shape (n_obs, n_dims)</p>
<ul>
<li>Each row is a estimated location with colums being cartesian
coordinates 2D or 3D.</li>
</ul>
</blockquote>
<p><strong>Returns</strong></p>
<blockquote><p><strong>mse</strong> : float</p>
<ul>
<li>Mean euclidean distance error</li>
</ul>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="sklearn_kt_regressor" class="doc_header"><code>class</code> <code>sklearn_kt_regressor</code><a href="https://github.com/elaird6/rfml_localization/tree/master/rfml_localization/core.py#L115" class="source_link" style="float:right">[source]</a></h3><blockquote><p><code>sklearn_kt_regressor</code>(<strong><code>skl_model</code></strong>=<em><code>Lasso()</code></em>, <strong><code>skl_kernel</code></strong>=<em><code>'laplacian'</code></em>, <strong><code>n_kernels</code></strong>=<em><code>1</code></em>, <strong><code>kernel_s0</code></strong>=<em><code>0.001</code></em>, <strong><code>kernel_s1</code></strong>=<em><code>None</code></em>, <strong><code>kernel_s2</code></strong>=<em><code>None</code></em>, <strong><code>n_meas_array</code></strong>) :: <code>BaseEstimator</code></p>
</blockquote>
<p>This is kernel trick regressor model class based on Sci-Kit Learn's
base estimator class. Estimator wraps any passed SKLearn model along
with kernel parameters which allows leveraging SKLearn tools and
methods for optimizing and tuning kernel trick models.</p>
<p><strong>Parameters</strong></p>
<blockquote><p><strong>skl_model</strong> : SKLearn estimator object, default = Lasso()</p>
<ul>
<li>Typical models used are Ridge() and Lasso() for regression</li>
</ul>
<p><strong>skl_kernel</strong> : str, default = 'laplacian'</p>
<ul>
<li>This determines kernel used in kernel trick - see scikit-learn's
pairwise kernels function. Values typically used here are 'rbf'
and 'laplacian' with other values including [‘additive_chi2’,
‘chi2’, ‘linear’, ‘poly’, ‘polynomial’, ‘sigmoid’, ‘cosine’]</li>
</ul>
<p><strong>n_kernels</strong> : integer, default = 1</p>
<ul>
<li>Number of kenerls concatenated together in kernel trick</li>
</ul>
<p><strong>kernel_s1-s3</strong> : float, default = 1e-3, None, None</p>
<ul>
<li>Kernel scales applied to each of the <code>skl_kernel</code>s.  The total
number of kernels deteremined by <code>kernel_scales</code></li>
</ul>
<p><strong>n_meas_array</strong> : integer ndarray, default = np.array([])</p>
<ul>
<li>ndarray that provides the number of each type of measurements
 (112ea TDOA, 16ea RSS, 8ea AoA is np.array([112,16,8])).  Note
 that if one measurement then defaults to simply pairwise_kernel
 for entire dictionary.</li>
</ul>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="sklearn_kt_regressor.fit" class="doc_header"><code>sklearn_kt_regressor.fit</code><a href="https://github.com/elaird6/rfml_localization/tree/master/rfml_localization/core.py#L158" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>sklearn_kt_regressor.fit</code>(<strong><code>X</code></strong>, <strong><code>y</code></strong>)</p>
</blockquote>
<p>Kernelizes passed data and then fits data according to passed
model.  Function inherits all attributes and features of
SKLearn's base esimator class as well as passed model.  As part
of fit process, feature data is kernelized (based on instance
kernel parameter) and normalized -- should parameterize
normalization or functionalize both together outside <code>fit</code>.</p>
<p><strong>Parameters</strong></p>
<blockquote><p><strong>X</strong> : ndarray of shape (n_samples, n_features)</p>
<ul>
<li>Training data</li>
</ul>
<p><strong>y</strong> : ndarray of shape (n_samples, spatial dimensions)</p>
<ul>
<li>Response data (location of Tx for each sample set
of measurements)</li>
</ul>
</blockquote>
<p><strong>Returns</strong></p>
<blockquote><p>Self, sets self.X<em>, self.Y</em></p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="sklearn_kt_regressor.predict" class="doc_header"><code>sklearn_kt_regressor.predict</code><a href="https://github.com/elaird6/rfml_localization/tree/master/rfml_localization/core.py#L213" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>sklearn_kt_regressor.predict</code>(<strong><code>X</code></strong>)</p>
</blockquote>
<p>Applies pair-wise kernel between observed with fitted data.  The
predicts based on fitted model. As part of predict process,
feature data is kernelized (based on instance kernel parameter)
and normalized -- should parameterize normalization or
functionalize both together outside <code>predict</code>.</p>
<p><strong>Parameters</strong></p>
<blockquote><p><strong>X</strong> : ndarray of shape (n_samples, n_features)</p>
<ul>
<li>Sample data used for predictions</li>
</ul>
</blockquote>
<p><strong>Returns</strong></p>
<blockquote><p>Estimated target(s)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<hr>
<h3 id="sklearn_kt_regressor-Example">sklearn_kt_regressor Example<a class="anchor-link" href="#sklearn_kt_regressor-Example"> </a></h3><p>Show basic usage of model.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">rfml_localization.RFsimulation</span> <span class="k">as</span> <span class="nn">rfsim</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">Ridge</span><span class="p">,</span> <span class="n">Lasso</span>

<span class="c1">#generate channel scenario using default channel parameters</span>
<span class="n">RFchannel_scenario1</span> <span class="o">=</span> <span class="n">rfsim</span><span class="o">.</span><span class="n">RFchannel</span><span class="p">()</span>

<span class="c1">#from channel scenario, generate locations for Tx and Rx and set of location observations</span>
<span class="n">RFchannel_scenario1</span><span class="o">.</span><span class="n">generate_RxTxlocations</span><span class="p">(</span><span class="n">n_rx</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">n_runs</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span> <span class="n">rxtx_flag</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="c1">#generate set of measurements based on each location observations</span>
<span class="n">RFchannel_scenario1</span><span class="o">.</span><span class="n">generate_Xmodel</span><span class="p">()</span>

<span class="c1">#assign features and response, then split into test/train</span>
<span class="n">X</span><span class="o">=</span><span class="n">RFchannel_scenario1</span><span class="o">.</span><span class="n">X_model</span>
<span class="n">y</span><span class="o">=</span><span class="n">RFchannel_scenario1</span><span class="o">.</span><span class="n">rxtx_locs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
<span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.33</span><span class="p">)</span>

<span class="c1">#based on knowledge of measurement, can derive from class instance</span>
<span class="c1">#variables (shape[1] of rxx_delay_, rxx_rss_, rxx_aoa_)</span>
<span class="n">num_meas_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">15</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span> 
<span class="n">kernel_s0</span><span class="p">,</span> <span class="n">kernel_s1</span><span class="p">,</span> <span class="n">kernel_s2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.13e-06</span><span class="p">,</span> <span class="mf">2.07e-03</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>

<span class="c1">#create estimator model</span>
<span class="n">kt_model</span> <span class="o">=</span> <span class="n">sklearn_kt_regressor</span><span class="p">(</span><span class="n">skl_model</span> <span class="o">=</span> <span class="n">Ridge</span><span class="p">(),</span> <span class="n">skl_kernel</span> <span class="o">=</span> <span class="s1">&#39;rbf&#39;</span><span class="p">,</span> 
                                <span class="n">n_kernels</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">kernel_s0</span> <span class="o">=</span> <span class="n">kernel_s0</span><span class="p">,</span> <span class="n">kernel_s1</span> <span class="o">=</span> <span class="n">kernel_s1</span><span class="p">,</span> 
                                <span class="n">kernel_s2</span> <span class="o">=</span> <span class="n">kernel_s2</span><span class="p">,</span> <span class="n">n_meas_array</span><span class="o">=</span><span class="n">num_meas_array</span><span class="p">)</span>

<span class="c1">#show methods inherited from SKLearn which are useful</span>
<span class="n">kt_model</span><span class="o">.</span><span class="n">set_params</span><span class="p">(</span><span class="n">skl_model__alpha</span> <span class="o">=</span> <span class="mf">1.83e-06</span><span class="p">)</span>

<span class="c1">#fit model</span>
<span class="n">kt_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span><span class="n">y_train</span><span class="p">)</span>

<span class="c1">#predict</span>
<span class="n">y_pred</span> <span class="o">=</span> <span class="n">kt_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

<span class="c1">#error</span>
<span class="n">mse</span> <span class="o">=</span> <span class="n">mean_squared_error</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span><span class="n">y_pred</span><span class="p">)</span>
<span class="n">msec</span> <span class="o">=</span> <span class="n">mse_EucDistance</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span><span class="n">y_pred</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-----------------------------------------------------------------------------------------------&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Mean summed/mean physical distance error for (x,y) location estimation: </span><span class="si">{:3.1f}</span><span class="s1"> / </span><span class="si">{:3.1f}</span><span class="s1"> meters&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mse</span><span class="p">,</span><span class="n">msec</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-----------------------------------------------------------------------------------------------&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>-----------------------------------------------------------------------------------------------
Mean summed/mean physical distance error for (x,y) location estimation: 11.0 / 4.0 meters
-----------------------------------------------------------------------------------------------
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="glmnet_kt_regressor" class="doc_header"><code>class</code> <code>glmnet_kt_regressor</code><a href="https://github.com/elaird6/rfml_localization/tree/master/rfml_localization/core.py#L256" class="source_link" style="float:right">[source]</a></h3><blockquote><p><code>glmnet_kt_regressor</code>(<strong><code>glm_alpha</code></strong>=<em><code>1</code></em>, <strong><code>lambdau</code></strong>=<em><code>0.001</code></em>, <strong><code>skl_kernel</code></strong>=<em><code>'laplacian'</code></em>, <strong><code>n_kernels</code></strong>=<em><code>1</code></em>, <strong><code>kernel_s0</code></strong>=<em><code>0.001</code></em>, <strong><code>kernel_s1</code></strong>=<em><code>None</code></em>, <strong><code>kernel_s2</code></strong>=<em><code>None</code></em>, <strong><code>n_meas_array</code></strong>, <strong><code>glmnet_args</code></strong>=<em><code>{}</code></em>) :: <code>BaseEstimator</code></p>
</blockquote>
<p>This is kernel trick regressor model class based on Sci-Kit Learn's
base estimator class. Estimator wraps a GLMnet model along
with kernel parameters which allows leveraging SKLearn tools and
methods for optimizing and tuning kernel trick models.</p>
<p>See <a href="https://glmnet-python.readthedocs.io/en/latest/glmnet_vignette.html">Glmnet Vignette</a>
for indepth information on GLMnet model.</p>
<p><strong>Parameters</strong></p>
<blockquote><p><strong>glm_alpha</strong> : float, default = 1</p>
<ul>
<li>glmnet elasticnet parameter where<ul>
<li>0 is Ridge regressino</li>
<li>1 is Lasso</li>
<li>(0,1) is ElasticNet</li>
</ul>
</li>
</ul>
<p><strong>lambdau</strong> : float, default = 1e-3</p>
<ul>
<li>lambda for penalty (aka alpha in SKLearn). Note that this is
converted to an ndarray internally due GLMnet accepting an
array of lambda's.  <strong>This is not supported with this wrapper!</strong></li>
</ul>
<p><strong>skl_kernel</strong> : str, default = 'laplacian'</p>
<ul>
<li>This determines kernel used in kernel trick - see scikit-learn's
pairwise kernels function. Values typically used here are 'rbf'
and 'laplacian' with other values including [‘additive_chi2’,
‘chi2’, ‘linear’, ‘poly’, ‘polynomial’, ‘sigmoid’, ‘cosine’]</li>
</ul>
<p><strong>n_kernels</strong> : integer, default = 1</p>
<ul>
<li>Number of kenerls concatenated together in kernel trick</li>
</ul>
<p><strong>kernel_scales</strong> : integer ndarray, default = np.array([])</p>
<ul>
<li>Kernel scales applied to each of the <code>skl_kernel</code>.  The total
number of kernels deteremined by <code>kernel_scales</code></li>
</ul>
<p><strong>n_meas_array</strong> : integer ndarray, default = np.array([])</p>
<ul>
<li>ndarray that provides the number of each type of measurements
 (112ea TDOA, 16ea RSS, 8ea AoA is np.array([112,16,8])).  Note
 that if one measurement then defaults to simply pairwise_kernel
 for entire dictionary.</li>
</ul>
<p><strong>glmnet_args</strong> : dictionary, default = {}</p>
<ul>
<li>parameters for underlying GLMnet object</li>
</ul>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="glmnet_kt_regressor.fit" class="doc_header"><code>glmnet_kt_regressor.fit</code><a href="https://github.com/elaird6/rfml_localization/tree/master/rfml_localization/core.py#L331" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>glmnet_kt_regressor.fit</code>(<strong><code>X</code></strong>, <strong><code>y</code></strong>)</p>
</blockquote>
<p>Kernelizes passed data and then fits data according to passed
model.  Function inherits all attributes and features of
SKLearn's base esimator class as well as passed model.  As part
of fit process, feature data is kernelized (based on instance
kernel parameter) and normalized -- should parameterize
normalization or functionalize both together outside <code>fit</code>.</p>
<p><strong>Parameters</strong></p>
<blockquote><p><strong>X</strong> : ndarray of shape (n_samples, n_features)</p>
<ul>
<li>Training data</li>
</ul>
<p><strong>y</strong> : ndarray of shape (n_samples, spatial dimensions)</p>
<ul>
<li>Response data (location of Tx for each sample set
of measurements)</li>
</ul>
</blockquote>
<p><strong>Returns</strong></p>
<blockquote><p>Self, sets self.X<em>, self.Y</em></p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="glmnet_kt_regressor.predict" class="doc_header"><code>glmnet_kt_regressor.predict</code><a href="https://github.com/elaird6/rfml_localization/tree/master/rfml_localization/core.py#L389" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>glmnet_kt_regressor.predict</code>(<strong><code>X</code></strong>)</p>
</blockquote>
<p>Applies pair-wise kernel between observed with fitted data.  The
predicts based on fitted model.  As part of predict process,
feature data is kernelized (based on instance kernel parameter)
and normalized -- should parameterize normalization or
functionalize both together outside <code>predict</code>.</p>
<p><strong>Parameters</strong></p>
<blockquote><p><strong>X</strong> : ndarray of shape (n_samples, n_features)</p>
<ul>
<li>Sample data used for predictions</li>
</ul>
</blockquote>
<p><strong>Returns</strong></p>
<blockquote><p>Estimated target(s)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<hr>
<h3 id="glmnet_kt_regressor-Example">glmnet_kt_regressor Example<a class="anchor-link" href="#glmnet_kt_regressor-Example"> </a></h3><p>Show basic usage of class</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#based on knowledge of measurement, can derive from class instance</span>
<span class="c1">#variables (shape[1] of rxx_delay_, rxx_rss_, rxx_aoa_)</span>
<span class="n">num_meas_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">15</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span> 
<span class="n">kernel_scales</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.13e-06</span><span class="p">,</span> <span class="mf">2.07e-03</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>

<span class="c1">#create estimator model</span>
<span class="n">kt_glm_model</span> <span class="o">=</span> <span class="n">glmnet_kt_regressor</span><span class="p">(</span><span class="n">glm_alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">lambdau</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">skl_kernel</span> <span class="o">=</span> <span class="s1">&#39;rbf&#39;</span><span class="p">,</span> 
                                   <span class="n">n_kernels</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">kernel_s0</span> <span class="o">=</span> <span class="n">kernel_s0</span><span class="p">,</span> 
                                   <span class="n">kernel_s1</span> <span class="o">=</span> <span class="n">kernel_s1</span><span class="p">,</span> <span class="n">kernel_s2</span> <span class="o">=</span> <span class="n">kernel_s2</span><span class="p">,</span> 
                                   <span class="n">n_meas_array</span><span class="o">=</span><span class="n">num_meas_array</span><span class="p">,</span> <span class="n">glmnet_args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">family</span><span class="o">=</span><span class="s1">&#39;mgaussian&#39;</span><span class="p">,</span> 
                                   <span class="n">standardize</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

<span class="c1">#fit</span>
<span class="n">kt_glm_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span><span class="n">y_train</span><span class="p">)</span>

<span class="c1">#predict</span>
<span class="n">y_pred</span> <span class="o">=</span> <span class="n">kt_glm_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
<span class="n">mse</span> <span class="o">=</span> <span class="n">mean_squared_error</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span><span class="n">y_pred</span><span class="p">)</span>
<span class="n">msec</span> <span class="o">=</span> <span class="n">mse_EucDistance</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span><span class="n">y_pred</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-----------------------------------------------------------------------------------------------&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Mean summed/mean physical distance error for (x,y) location estimation: </span><span class="si">{:3.1f}</span><span class="s1"> / </span><span class="si">{:3.1f}</span><span class="s1"> meters&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mse</span><span class="p">,</span><span class="n">msec</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-----------------------------------------------------------------------------------------------&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>-----------------------------------------------------------------------------------------------
Mean summed/mean physical distance error for (x,y) location estimation: 23.3 / 5.9 meters
-----------------------------------------------------------------------------------------------
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

</div>
 

